우측값 레퍼런스 >>

예외사항 throw , noexcept
문제가 있어서 deprecated 되고 noexcept 성능향상이득 봄

우측값 참조란 기능이 추가되어 복사가 아닌 메모리 이동이 가능.
&&

std::move는 이동대입연산자임 (좌측값을 우측값으로 캐스팅)
우측값은 식이 끝나면 사라지는 값이다 고로 move를 사용해 좌->우측값으로 바꿨을경우 
우측값으로 바뀐 좌측값은 다음에 사용x

우측값 참조는 우측값이 아니다 ,
우측값은 임시값이지만 우측값 참조는 임시값이 아니다.

이말은 우측값 참조를 가지는 매개변수는 우측값이  아니니 LValue 값을 가진다(?)
그러니 좌측값은 좌측 값, 우측값은 우측값으로 캐스팅 해줘야하는데
이를 가능케하는 함수가 std::forward<T>(CASTING) ;

1. 식이 끝난 후 계속 존재하는 갑은 좌측 값, 식이 끝나면 존재하지 않는 임시값은 우측값
2. '&'을 사용한 참조를 정확하게는 'Lvalue Reference' 라고 부른다. 사용 방법은 기존의 참조와 비슷하여 참    조가 '&'을 사용햇듯이 ' &&'를 사용
3. 좌측값 참조는 좌측값을 참조하고, 우측 값 참조는 우측 값을 참조한다.
4. 불필요한 복사를 없앨 수 있는 것은 바로 우측 값 참조의 Move semantics 덕택.
   Move semantics에 의해서 C++0x에서는 기존에 없는 'move 생성자','move 대입 연산자'라는 것이 생겼음
5. 'move 생성자' 'move 연산자'는 암묵적으로는 만들어지지 않으면 '복사 생성자'가 'move 생성자'보다 우선순    위가 높고, '대입 연산자'가 'move 대입 연산자'보다 우선 순위가 높다.
6. 표준 라이브러리에서 제공하는 std::move를 사용하면 좌측 값을 우측 값으로 타입 캐스팅 할 수 있다.
7. 우측 값 참조와 좌측 값 참조는 타입이 다르므로 함수 오버로드를 적용할 수 있다.
8. 우측 값 참조는 우측 값이 아니다.
9. std::forward 함수는 좌측 값은 좌측 값으로, 우측 값은 우측 값으로 캐스팅 해준다.

출처: https://skstormdummy.tistory.com/entry/우측-값-참조-RValue-Reference [성가비의 세계(임시)]

복사생략
복사를 하지않고 바로 데이터를 이동하는것이 효율적인 경우가 많다.
그래서 이동생성자, 이동대입연산자라는 개념이 탄생한다.
전체를 복사할 필요없이 임시객체가 가리키고 있던 데이터로 바꿔주면된다.
임시 객체소멸시 메모리를 해제하지 못하게해야한다. 
만약 그렇게 하지 않는다면 delete 하기때문에 해당 이동데이터를 nullptr로 바꿔야함.
소멸자 역시 nullptr아닐시에만 delete하도록 해야함.

이동 생성자 작성 시 주의
noexcept 명시.
이동생성자 경우 예외발생시 기존의 메모리가 존재한다는 것을 모르기에 해제가 섣불리 불가능
vector(다른 컨테이너도 마찬가지)의 경우 이동생성자 예외 시 제대로된 처리불가능.
그래서 noexcept가 아닌이상 이동생성자가 실행이 안되니 명시가 필요하다./ 