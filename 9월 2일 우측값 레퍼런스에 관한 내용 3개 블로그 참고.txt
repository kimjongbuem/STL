우측값 레퍼런스 >>

예외사항 throw , noexcept
문제가 있어서 deprecated 되고 noexcept 성능향상이득 봄

우측값 참조란 기능이 추가되어 복사가 아닌 메모리 이동이 가능.
&&

std::move는 이동대입연산자임 (좌측값을 우측값으로 캐스팅)
우측값은 식이 끝나면 사라지는 값이다 고로 move를 사용해 좌->우측값으로 바꿨을경우 
우측값으로 바뀐 좌측값은 다음에 사용x

우측값 참조는 우측값이 아니다 ,
우측값은 임시값이지만 우측값 참조는 임시값이 아니다.

이말은 우측값 참조를 가지는 매개변수는 우측값이  아니니 LValue 값을 가진다(?)
그러니 좌측값은 좌측 값, 우측값은 우측값으로 캐스팅 해줘야하는데
이를 가능케하는 함수가 std::forward<T>(CASTING) ;

1. 식이 끝난 후 계속 존재하는 갑은 좌측 값, 식이 끝나면 존재하지 않는 임시값은 우측값
2. '&'을 사용한 참조를 정확하게는 'Lvalue Reference' 라고 부른다. 사용 방법은 기존의 참조와 비슷하여 참    조가 '&'을 사용햇듯이 ' &&'를 사용
3. 좌측값 참조는 좌측값을 참조하고, 우측 값 참조는 우측 값을 참조한다.
4. 불필요한 복사를 없앨 수 있는 것은 바로 우측 값 참조의 Move semantics 덕택.
   Move semantics에 의해서 C++0x에서는 기존에 없는 'move 생성자','move 대입 연산자'라는 것이 생겼음
5. 'move 생성자' 'move 연산자'는 암묵적으로는 만들어지지 않으면 '복사 생성자'가 'move 생성자'보다 우선순    위가 높고, '대입 연산자'가 'move 대입 연산자'보다 우선 순위가 높다.
6. 표준 라이브러리에서 제공하는 std::move를 사용하면 좌측 값을 우측 값으로 타입 캐스팅 할 수 있다.
7. 우측 값 참조와 좌측 값 참조는 타입이 다르므로 함수 오버로드를 적용할 수 있다.
8. 우측 값 참조는 우측 값이 아니다.
9. std::forward 함수는 좌측 값은 좌측 값으로, 우측 값은 우측 값으로 캐스팅 해준다.

출처: https://skstormdummy.tistory.com/entry/우측-값-참조-RValue-Reference [성가비의 세계(임시)]