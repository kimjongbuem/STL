기초 c++ 재복습 3
const도 오버라이딩 조건임.

A - friend -> B // B가 A의 모든 내용을 가져다 씀
A가 친구니까 다줘야지~

클래스의 friend 선언
friend class className // 이 선언은 해당 클래스의 모든 내용을 가져다 쓸수 있다는 내용임. private 내용도 마찬가지 다만 정보은닉을 무너뜨리니 소극적자세로.. 부탁

함수의 friend 선언
전역함수대상으로도 클래스의 멤버함수를 대상으로도 friend선언이 가능하다.

c++에서의 static 
기존의 공부했던 디자인패턴에 대한 내용도 감미하자 - 싱글턴패턴

mutable : const 함수내에서의 값의 변경을 예외적허용
해당 뮤터블 멤버 변수는 해당 const함수에서의 값을 바꾸기가 가능하다. mutable type name
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
연산자 오버로딩에 대한 내용) *** 
c++ 문법만 있는 operator 연산자 오버로딩에 대한 내용이다.
멤버함수 / 전역함수에 따라 정의 내용이 다른데,
멤버함수의 경우 Point operator+(Point& p){}
전역함수의 경우 friend Point operator(Point& p1, Point& p2); => 전역으로 정의. 

단항연산자 오버로딩-
증감 연산자 오버로딩
++pos; 
멤버함수) pos.operator++( ); 전역함수) operator++(pos);

근디 pos++의 경우는 다르다.
멤버함수) pos.operator++(int); 전역함수) operator++(pos, int);
const Point operator++(int){
	const Point retobj(xpos,ypos);
	xpos+=1; ypos+=1;
	return retobj; // 이런식 const객체를 선언하는 것을 통해 (pos++)++ 하는 이런 연산을 방지함.
}
교환 법칙 문제의 해결?
Point operator*(int times) { } // pos * 3
전역함수의 형태로 오버로딩을 하면 교환법칙을 성립시키기 가능함

Point operator*(int times,Point& ref) {} // 3 * pos 가능

cout/endl/cin 정체 
<<, >>

대입연산자 오버로딩***
디폴트 대입연산자가 있었구 깊은복사를 진행하고싶다면 직접 정의해야한다.

상속관계의 디폴트 대입연산자의 특징에 대해 고찰해보자
만약 base - derived 클래스의 경우 derived클래스가 디폴트 생성자라면 기초클래스의 대입연산자를 호출하지만,
그렇지 않은경우엔 명시적으로 기초 클래스의 대입 연산자 호출문을 삽입하지 않을 경우 기초 클래스의 대입 연산자는 호출되지 않아 
기초클래스의 멤버 변수는 멤버 대 멤버의 복사 대상에서 제외된다.

배열의 인덱스 연산자 오버로딩
경계검사 x -> exception을 만들자!

type& operator[ ](int idx) {
	array bound check code
	return arr[idx];
}
배열간의 복사와 대입의 경우 원천적으로 막을 필요성이 생긴다 그래서 private에다가 함수를 넣어서 방지하는 경우도 있다.
또한 const를 추가하여 해당 함수가 값만을 반환하도록 하게 할수 있다.

그 외 연산자 오버로딩 **
new 연산자 오버로딩은 좀 차이점이 있다.
일단 new 연산자 오버로딩의 하는일은 
메모리할당, 생성자의 호출, 할당하고자하는 자료형에 맞게 반환된 주소 값의 형 변환

우리는 메모리 할당부분만 오버로딩이 가능하다.
약속 -- static method
void * operator new(size_t size){
	void* adr = new char[size];
	return adr;
}
void * operator new[ ](size_t size){
	void* adr = new char[size];
	return adr;
}

스마트 포인터의 기초, 포인터 연산자 오버로딩

operator*, ->() 오버로딩

펑터 operator( ) 어떠한 다른 기준을 주어서 표현을 하고 보여주고싶을때 유용함..

서로 다른 자료형이더라고 임시객체를 생성해서 대입연산이 이루어질수도 있다..
객체를 기본자료형으로 형변환또한 가능하다. operator int(){ return num;} // 이런식.... 






