기초 c++ 재복습 3
const도 오버라이딩 조건임.

A - friend -> B // B가 A의 모든 내용을 가져다 씀
A가 친구니까 다줘야지~

클래스의 friend 선언
friend class className // 이 선언은 해당 클래스의 모든 내용을 가져다 쓸수 있다는 내용임. private 내용도 마찬가지 다만 정보은닉을 무너뜨리니 소극적자세로.. 부탁

함수의 friend 선언
전역함수대상으로도 클래스의 멤버함수를 대상으로도 friend선언이 가능하다.

c++에서의 static 
기존의 공부했던 디자인패턴에 대한 내용도 감미하자 - 싱글턴패턴

mutable : const 함수내에서의 값의 변경을 예외적허용
해당 뮤터블 멤버 변수는 해당 const함수에서의 값을 바꾸기가 가능하다. mutable type name
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
연산자 오버로딩에 대한 내용) *** 
c++ 문법만 있는 operator 연산자 오버로딩에 대한 내용이다.
멤버함수 / 전역함수에 따라 정의 내용이 다른데,
멤버함수의 경우 Point operator+(Point& p){}
전역함수의 경우 friend Point operator(Point& p1, Point& p2); => 전역으로 정의. 

단항연산자 오버로딩-
증감 연산자 오버로딩
++pos; 
멤버함수) pos.operator++( ); 전역함수) operator++(pos);

근디 pos++의 경우는 다르다.
멤버함수) pos.operator++(int); 전역함수) operator++(pos, int);
const Point operator++(int){
	const Point retobj(xpos,ypos);
	xpos+=1; ypos+=1;
	return retobj; // 이런식 const객체를 선언하는 것을 통해 (pos++)++ 하는 이런 연산을 방지함.
}
교환 법칙 문제의 해결?
Point operator*(int times) { } // pos * 3
전역함수의 형태로 오버로딩을 하면 교환법칙을 성립시키기 가능함

Point operator*(int times,Point& ref) {} // 3 * pos 가능

cout/endl/cin 정체 
<<, >>

대입연산자 오버로딩***
디폴트 대입연산자가 있었구 깊은복사를 진행하고싶다면 직접 정의해야한다.

상속관계의 디폴트 대입연산자의 특징에 대해 고찰해보자
만약 base - derived 클래스의 경우 derived클래스가 디폴트 생성자라면 기초클래스의 대입연산자를 호출하지만,
그렇지 않은경우엔 명시적으로 기초 클래스의 대입 연산자 호출문을 삽입하지 않을 경우 기초 클래스의 대입 연산자는 호출되지 않아 
기초클래스의 멤버 변수는 멤버 대 멤버의 복사 대상에서 제외된다.

배열의 인덱스 연산자 오버로딩
경계검사 x -> exception을 만들자!

type& operator[ ](int idx) {
	array bound check code
	return arr[idx];
}
배열간의 복사와 대입의 경우 원천적으로 막을 필요성이 생긴다 그래서 private에다가 함수를 넣어서 방지하는 경우도 있다.
또한 const를 추가하여 해당 함수가 값만을 반환하도록 하게 할수 있다.

그 외 연산자 오버로딩 **
new 연산자 오버로딩은 좀 차이점이 있다.
일단 new 연산자 오버로딩의 하는일은 
메모리할당, 생성자의 호출, 할당하고자하는 자료형에 맞게 반환된 주소 값의 형 변환

우리는 메모리 할당부분만 오버로딩이 가능하다.
약속 -- static method
void * operator new(size_t size){
	void* adr = new char[size];
	return adr;
}
void * operator new[ ](size_t size){
	void* adr = new char[size];
	return adr;
}

스마트 포인터의 기초, 포인터 연산자 오버로딩

operator*, ->() 오버로딩

펑터 operator( ) 어떠한 다른 기준을 주어서 표현을 하고 보여주고싶을때 유용함..

서로 다른 자료형이더라고 임시객체를 생성해서 대입연산이 이루어질수도 있다..
객체를 기본자료형으로 형변환또한 가능하다. operator int(){ return num;} // 이런식....

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*****
템플릿 문법 관련 내용
template <typename T>
T add(T n1, T n2) {}  // 함수 템플릿
-> int가 들어가는 컴파일  
int add<int>(int n1, int n2){}  // 템플릿 함수
원형은 이렇고 이렇게 호출하면 불편하니... add(10,20) 이렇게 호출해도 컴파일러가 자료형을 참조하여 호출될 함수의 유형을 결정해준다.
컴파일시 함수가 만들어지고 한번쓰인함수는 이미 만들어진 함수를 쓰는 식이다.(컴파일 시간 신경쓸 요소이긴 한데 미미함..)

template <typename T1, typename T2>의경우 호출시엔 호출형태를 완전히 갖춰야한다.

함수 템플릿 특수화
template<> // 해당 템플릿은 이걸로 지정해서 기존 템플릿과 다른 작업을 실시! 함수임.

클래스 템플릿)
객체생성시 무조건 자료형 명시. 템플릿은 모든 내용 header,cpp(구현)내용이 모두있어야함.

클래스 템플릿의 경우 클래스가 있는데 그 클래스가 다른 클래스 템플릿을 가진경우 ex) dress<cap<double>> 
friend 선언을 하여 일반함수처럼 쓸수있다) Point 클래스 템플릿에서 operator friend .

클래스 템플릿의 특수화
특정 자료형을 기반으로 생성된 객체에 대해 구분이 되는 다른 행동양식을 적용하기 위함임. == 클래스라는 뜻....
클래스 템플릿의 부분 특수화
template <t1, int> 이런식으로 2개이상의 자료형이 있고 단 하나만이라도 정해져 있지않은 자료형이 있다면 부분 특수화임 얘는 템플릿.

템플릿인자)
템플릿인자또한 객체의 특성이니 만약 <int 5> <int 7> 동일한 템플릿기준 인자만 이렇게 다르게 객체를 생성했다고 하면 이 둘은 완전히 다른 객체(다른 타입)임.
디폴트 값 지정 가능.

템플릿 - static)
template <class T>
void show(){
	static T num = 0;
	num+=1;
	cout<<num<<endl;
}
이 show함수를 다른 자료형으로 생성하고 호출할때마다 해당 자료형에 따라 static 지역 변수가 유지된다.
물론 클래스 경우) 초기화도 가능 
template <class T> T show<T>::num = 0; // show라는 클래스 템플릿의 static num을 0 초기화
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
예외처리
try catch throw 
catch(...) 모든예외 ok!
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
c++ 형변환 연산자내용 **
쓰는법 예) static_cast<truck*>(pcar);

static_cast
근데 다이나믹아?
내가 상위클래스긴 하지만 유도클래스를 가리키고 있는데 , 이때 자료형을 유도로 바꾸고싶어... 그럼? 나를 써(다만 상위가 상위를 가리키는데 유도로 바꾸는것은 위험하다)
const_cast
const 선언한 타입의 아이들을 const 기능제거
dynamic_cast
상속 관계에서의 안전한 형변환
유도클래스 -> 상위 클래스로만 변형이가능함.
단 polymorphic  클래스의 경우 상위 -> 유도로 가능한데, 가상함수를 가지는 클래스를 의미함.
가리킬수 없는 상황시 null반환 함. / 참조자는 null반환불가하니 bad_cast expt 발생.
reinterptret_cast
상관없는 자료형 변환



