가변인수함수에대해 알아보자.

printf 함수의 원형?
int printf(const char* format...); ???
서식문자열을 가지고있음...  ellipsis ... 이 적혀있다 . ( 이후의 인수에는 컴파일러가 개수와 타입을 점검하지 않을것이다.)
즉 개수, 타입을 상관하지 않고 그대로 함수에게 넘겨주니 가변인수에 대한 적합성이 맞게된다.
대신 전달된 인수의 정확한 타입을 판별하여 꺼내어 쓰는 것은 함수가 알아서 처리해야 한다.
컴파일러는 얼마든지 인수가 오는것을 무관심하기때문에 뒷일은 책임 안진다.
여기서 format은 고정인수인데 고정인수는 원형에 타입과 개수가 분명히 명시되어 있으니 무조건 그 명시된 내용을 따라야함.
그럼 만드는방법은?
void varFunc(int fix ...){
	va_list ap;
	va_start(ap,fix);
	while(모든 함수를 읽을때까지){
		var_arg(ap,인수타입);
	}	
	va_end(ap);
}
매개변수 위치에는 내가 반드시 넣어야할 애들을 원하는 만큼 넣어줄수 있고 걔들은 반드시 지켜줘야함 대신 ...이후로는 상관이없다.

va_list ap; 
함수로 전달되는 인수들은 스택이라는 기억장소로 저장이되고 함수는 스택에서 인수를 꺼내 쓴다.
스택에 있는 인수를 읽을 때 포인터 연산을 해야하는데 현재 읽고 있는 번지를 기억하기 위해
va_list형의 포인터 변수하나가 필요하다.(이름규칙에 따라 ap로 많이 짓는다)
va_list 타입은 char*형으로 정의 됨 가변인수를 읽기 위한 포인터 변수를 선언했다고 보면 된다.
(즉 번지를 저장하는 변수다.)

va_start(ap, 마지막 고정인수)
이 명령은 가변 인수를 읽기 위한 준비를 하는데 ap 포인터 변수가 첫번째 가변인수를 가리키도록 초기화함
첫 번째 가변 인수의 번지를 조사하기 위해서 마지막 고정 인수를 전달해 주어야 한다.
va_start 내부에서는 마지막 고정 인수 다음 번지로 ap를 맞추어 주므로 이후로 ap번지를 읽으면 순서대로 가변 인수를 읽을 수 있다.

va_arg(ap, 인수타입)
가변인수를 실제로 읽는 명령임. va_start가 ap를 첫번째 가변인수 번지로 맞추어주었으니 ap위치에 있는 값을'
읽기만 하면 된다. 
단, ap번지에 있는 값이 어떤 타입인지 알아야 하므로 두번째 인수로 읽고자 하는 값의
타입을 지정해 주어야한다. 이말은 ap위치에 있는 정수값을 읽고자 한다면 
va_arg(ap,int)를 호출하고 실수값을 읽고자 한다면 va_arg(ap, double)이라고 호출하면 된다.
이명령은 ap 위치에서 타입에 맞는 값을 읽어 리턴해 주며 ap를 다음 가변 인수 위치로 이동한다.
그래서 va_arg를 반복적 호출하면 전달된 가변인수를 순서대로 읽을수 있는것이다.
그럼 이 인수타입을 어떻게 하면 적절하게 전달이 가능한가?
va_arg가 매크로 함수이기에 가능한일 두번째 인수는 내부적으로 sizeof, 캐스트 연산자로 전달되기때문.

va_end(ap)
가변인수를 다 읽은 후 뒷정리 별다른 처리 x 단 필요한 이유는 호환성이다.
플랫폼에 따라 가변 인수를 읽은후 뒷처리할 필요가 있기 때문.
적어도 인텔 cpu에서는 아무일도 안하지만 다른 플랫폼이나 미래의 환경을 위해서 관례적으로 넣어주자.

가변 인수 함수는 반드시 하나 이상의 고정 인수를 가져야 한다. 
첫 번째 인수부터 가변 인수일 수는 없는데 왜냐하면 가변 인수를 읽기 위한 포인터 ap를 초기화하기 위해서 마지막 고정 인수의 번지를 알아야 하기 때문이다. 
va_start 매크로는 마지막 고정 인수의 번지에 길이를 더해 가변 인수가 시작되는 번지를 계산하는데 고정 인수가 없으면 이 매크로가 동작하지 않는다.

매크로분석>>
va_매크로
포인터, sizeof 연산자, 비트연산들의 절묘한 동작.
typedef char *  va_list;

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)  ( ap = (va_list)&v + _INTSIZEOF(v) )

#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )

#define va_end(ap)      ( ap = (va_list)0 )

va_list는 char*형으로 정의 중요한것은 포인터 타입이라는것.
INTSIZEOF(n) 매크로는 인수로 전달된 타입의 n의 길이를  계산함.(4의 배수로 올림)

va_start 매크로는 가변 인수의 위치를 가리키는 포인터 ap 초기화 (마지막 고정 인수)

va_arg 함수는 ap를 일단 가변인수의 길이만큼 더해 다음 가변인수번지로 이동시킨다. 
그리고 다시 길이를 빼서 원래 자리로 돌아온 후 이번지를 t타입으로 캐스팅하여 * 그값을 읽는다.
이매크로는 ap의 길이를 더했다 뺐다 해야하기 때문에 그위치를 읽도록 되어있다,

가변인수 함수의 활용





[출처] Printf 구조 및 va_start, va_list 알아보자|작성자 윈드포유




