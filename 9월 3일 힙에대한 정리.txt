9월 3일 힙<- 참고 우선순위 큐내용
힙은 컨테이너가 아니라 데이터를 구성하는 방식임.
힙 - 트리를 이해해야함
힙은 완전이진트리다? 
------------------------------------------------
트리 데이터 구조의 의미)
트리는 노드로 이루어진 자료구조.
1. 하나의 루트노드를 가져야해.
2. 루트노드는 0개 이상의 자식 노드를 갖고있다.
3. 그자식노드또한 1과 2에 상응한다.(반복정의)

노드 - 간선 구성이며, 사이클 존재 x 특정순서로 나열가능할수도 아닐수도 있다.
그래프의 한종류 (사이클이 없는 하나의 연결 그래프 , DAG , 방향성이 있는 비순환 그래프)
특징 : 최소연결트리, 계층모델, 노사이클, 경로 유일성, 한개의 루트 노드( 부모도 1)
이진트리순회 (전중후위 순회 3개)

트리의 종류)
이진트리 / 완전이진트리(^ ^) / 포화이진트리 / 균형이진트리 / 전이진트리(모든노드가 0,2개 의 자식노드를 갖는 트리임)
이진탐색트리는 중복값 허용 x 
이진 힙)
트리의 마지막 단계에서 오른쪽 부분을 뺀 나머지 부분이 가득 채워져 있는 완전 이진트리

트라이) n차 트리의 변종 , 각 노드에 문자를 저장하는 자료구조
접두사를 빠르게 찾아보기 위한 흔한 방식 으로, 모든 언어를 트라이에 저장해 놓는 방식

https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html
--------------------------------------------------------------

c++ 힙을 다루는 함수는 algortihm 헤더에 템플릿으로 정의 되어있다.
예를 들어서 
vector<int> numbers ={1,3,45,6,8,7};
make_heap(begin(numbers),end(numbers), default = less<>); // 45, 8 .. 1 vector 정렬, default값은 greater<>넣어서 해도됨.
우선순위 큐가 바로 힙임.
그럼 priority vs make_heap은?
우선순위큐의 경우 접근가능한것이 맨 첫원소밖에 없다. 원소순서가 자동관리
메이크 힙의 경우 접근가능한 부분이 전부... 원소순서가 자동관리는 안됨.

힙 연산)))
얘를 들어서 해당 벡터 자료구조에 push_back을 하여 데이터를 추가했을시 힙 배열을 적적하게 유지ㅣ하기 위한 push_heap(begin, end)를 호출!
push_heap(begin(numbers),end(numbers), default = less<>);
<< 맨끝 입력받음..
ex)	words.push_back(word);
		push_heap(begin(words), end(words));

모든 힙연산이 원소전체가 내림차순으로 정렬되지 않을수 있다.
원소삭제시 make_heap -> pop_heap(begin(numbers),end(numbers), default = less<>); -> 해당자료구조.pop_back( ); // 맨 뒤의 원소가 삭제할 데이터가 됨. 

힙검사)
is_heap(begin(numbers),end(numbers), default = less<>) return bool val => 해당 자료구조가 힙인가?
특정범위 힙검사
-> auto iter = is_heap_until 힙이 아닌* 원소의 첫번째 위치를 반환한다.
만약 pop_heap을 호출한후 마지막원소만 힙 원소가 아니니 마지막원소반환됨(반복자...)

힙정렬)
sort_heap((begin(numbers), end(numbers), defalut= less<>());
최대힙/최소힙 - > 정렬된 힙(최소힙/최대힙 - 완벽정리) 

priority 처럼 복제 안해도됨...