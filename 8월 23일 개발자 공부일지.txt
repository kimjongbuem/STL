stack, queue, priority queue.

컨테이너 어댑터는 순차열 컨테이너를 다른 기능을 제공하는 순차열 컨테이너로 정의하기 위해 래핑하는 클래스 템플릿임.
다른기능을 제공하기 위해 컨테이너의 기존 인터페이스 확장, 이런 클래스 템플릿을 어댑터 클래스라 부른다.

그럼 stact<T> 에대해 알아보자. stackSTL.cpp 참고
일단 LIFO구조를 가진다는게 포인트(LAST IN FIRST OUT)
일단 stack<T>의 기반 순차열 컨테이너는 deque<T>가 기본이며 따라서 실제 템플릿 타입은 stack<typename T, typename Container=deque<T>)가 된다.
첫번째 인수는 저장할 객체의 타입, 두번쨰는 기반 컨테이너 타입임.
back, push_back, empty, size 연산만 지원하면 두번째 디큐타입과 다른 기반 컨테이너 지정이 가능하다.
초기화시 초기화 리스트에 있는 객체를 생성과 동시에 초기화가 불가하나, 기반 컨테이너와 같은 타입인 컨테이너의 원소들을 복제하는것은 가능하다.
EX)
list<double> values={1.12,2.45,154.5};
stack<double, list<double>> stackT (values); 
그럼 스택연산에 대해 알아보자.
top, push, pop, size, empty는 기본적으로 알고있구
emplace : emplace에 전달된 인수로 t 생성자를 호출하여 컨테이너 내부에 객체를 바로 생성하고 스택 상위에 객체를 추가한다.

즉, 들어갈 값(또는 struct)를 생성자로 생성한 다음에 그것을 복사해 새로 컨테이너에 넣는 메모리 낭비를 막아준다는 것이다.
출처: https://junis3.tistory.com/7 [프로그래밍 연습장]

개인적으로 push vs emplace를 찾아보다가
가변인자내용과 rvalue reference에대해 찾아보았다.

가변인자 함수는 예를 들어서 printf와 같이 인사의 형식이나 수가 정해지지않은 형식의 함수.
그러면 함수 호출규약은?
변수를 어떻게 넘길거고 리턴값이 존재하는가? 인수로 전달된 애들을 어떻게 처리할건가? 등등
그럼 함수 호출 규약이 뭐가있는지 파악해보자
__cdecl, __stdcall, __fastcall, thiscall, naked

 호출 규약	인수 전달 	스택 정리 	이름 규칙 
__cdecl	오른쪽부터	호출원	_함수명 
__ stdcall	오른쪽부터	함수	_함수명@인수크기
__fastcall	ECX, EDX에 처음 2개 전달, 나머지는 오른쪽 먼저	함수	@함수명@인수크기
thiscall	오른쪽부터, this를 ECX에 저장	함수	C++ 이름 규칙을 따름
naked	오른쪽부터	함수	없음

일반적으로 멤버 변수는 객체간에 공유가 안되지만, 함수는 공유가 됩니다.
변수는 객체마다 값이 다르지만 함수의 동작은 모두 같기 때문입니다.
어떤 객체가 함수를 호출했는지를 호출당한 함수는 알 수가 없습니다.
물론 프로그램을 만들때는 class명 A, B; 이런식으로 만들어서
A.함수명() 형식이기 때문에 알 수 있습니다.
하지만 컴파일러는 이것을 알지 못합니다.
그래서 호출한 객체의 정보를 ECX 레지스터에 넣습니다.
어떤 객체가 호출했는지 알 수 있게 해주기 위해서입니다.

객체가 메소드를 호출할 때는 알아서 컴파일러가 이런 호출 규약을 사용합니다.
swap(stack<T>& otherStack) : 현재스택에 있는 원소와 다른 스택에 있는 원소 교환, 인수는 현재 스택과 같은 타입으로 된 원소들을 담고 있어야 함. 











