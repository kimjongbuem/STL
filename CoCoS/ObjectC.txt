Objective-C 메모리관리

상위집합으로는 기본적으로 C의 메모리 관리 규칙을 따른다. 

1. alloc 할당한 메모리는 반드시 free해야함. alloc, free개수일치 반드시!
2. alloc을 수행한 함수가 free를 책임져야한다. 어려울 경우 호출하는 쪽에서 책임

strcpy를 잘생각해봐.
2개의 const char*, 하나의 size_t를 가져서 해제의 짝을 맞춰주는것이다~

Objective-C 메모리 관리 규칙
참조 카운트 방식 도입...
1. new, alloc, copy로 객체를 생성하는 경우 이 객체는 해당 시점에 1의 참조수
2. 객체를 쓰고 release 메시지 보냄 참조수 - 1 따라서 어떤 함수내에서, alloc 생성 객체에 release 메시지 보내면
해당 객체의 참조수는 0 런타임은 해당 객체를 파괴한다.
3. 함수 내에서 객체를 생성해서 반환하는 경우, 리턴하기전 autorelease 메시지를 보내어 오토릴리즈 풀이 해제
될 때까지 객체가 release 될수 있게한다.
4. 1방식이 아닌 다른 방식이라면 객체를 획득하는 시점에서 참조수 1로보고 autorelease 됨

그럼 오토릴리즈는 뭐냐?
함수 내에서 생성한 객체들을 적절한 시점에 한번에 해제할 수 있도록 해주는 방법 제공한다.
수동으로 retain 했다면 그 횟수만큼만 release 하면 된다.

-alloc : 해당 객체에 메모리를 할당하고 레퍼런스 카운트를 1 올립니다.
-retain : 해당 객체의 레퍼런스 카운트를 1 올립니다.
-copy : 해당 객체의 복사본을 만듭니다. 그리고 복사본의 레퍼런스 카운트를 1 올립니다.
-release : 해당 객체의 레퍼런스 카운트를 1 낮춥니다.
-autorelease : 정해지지 않은 시점에 해당 객체의 레퍼런스 카운트가 -1 낮아집니다.

즉 같은 공간에서 retain/release 하기 편한데 그렇지 못한 경우 autorelease를 사용하여 메모리를 관리함.
autorelease는 자동적으로 관리해줌!(반환시) 물론여러 클래스마다 다르지만... 이건 내가 오브젝트 시를 안할거기때문에 나중에 ...