c++ hinstance , hwnd 핸들
커널 오브젝
커널 오브젝트 : Windows 운영체제에서 리소스(Resource : 프로세스, 쓰레드, 파일)들을
                      관리하기 위한 데이터를 저장하는 메모리 블록






Windows에서 관리하는 리소스 특성을 변경하기 위해서는 해당 리소스의 커널 오브젝트를 조작해야한다.

해당 리소스의 정보를 저장하고 있는 커널 오브젝트에 접근하기 위해서는

커널 오브젝트들을 구별하는 커널 오브젝트 핸들(Object Handle)을 얻어야 한다.



커널 오브젝트와 핸들 :

커널 오브젝트는 Windows 운영체제에 종속적이다.

사용자가 리소스 생성을 요청하면 운영체제에서 사용자가 요청한 대로 리소스를 생성하게 되고

이를 관리하기 위해 커널 오브젝트를 생성한다.

즉, 커널 오브젝트는 Windows 운영체제에 의해 생성 및 소멸이 결정된다.


리소스가 생성되어 커널 오브젝트가 생성되면 커널 오브젝트에 핸들이 부여되고

부모 리소스도 구조체 변수를 통해 자식의 커널 오브젝트 핸들을 획득할 수 있다.

즉, 부모와 자식이 자식의 커널 오브젝트를 공유한다.

커널 오브젝트와 Usage Count :

운영체제는 해당 커널 오브젝트를 참조하는 대상이 하나도 없을때 커널 오브젝트를 소멸시킨다.

참조하는 대상은 Usage Count(참조 횟수)로 관리한다.

즉, Usage Count = 0 일 때 커널 오브젝트를 소멸한다.

리소스의 생성과 동시에 해당 커널 오브젝트의 Usage Count = 1 이된다.
생성이 완료되면 부모가 자식 리소스 커널 오브젝트의 핸들을 획득하기에 Usage Count = 2 가 된다.

만약 자식 리소스를 소멸하면 Usage Count 가 하나 줄어든다.

여기서 문제가 발생한다. 리소스가 소멸됬음에도 그 리소스를 관리하는 커널 오브젝트는 소멸되지 않는다.
(Usage Count 가 1이므로)

Usage Count = 0 을 만들기 위해선

부모의 자식의 커널 오브젝트 참조를 해제해야 한다.

CloseHandle() 함수를 사용하면 자식의 커널 오브젝트 핸들을 반환하여 참조를 해제한다.

즉, Usage Count 가 하나 줄어든다.

따라서 커널 오브젝트를 소멸하기 위해서는

부모가 소유한 자식의 커널 오브젝트 핸들을 반환해야 한다.

출처: https://dakuo.tistory.com/84 [hacker dakuo]

API 핸들 Handle

 

 

- 운영체제가 무언가를 식별하기 위한 키값을 핸들 이라고 한다. -> 이 키값으로 해당 핸들의 정보를 찾음.

 

- 핸들은 보통 32bit 정수형 값을 가지고 있다. 정수형이 비교가 제일 빨라

 

- 핸들번호는 운영체제가 정함 . 배급은 내가 한다 . 받아먹어라

 

- 핸들은 절대 중복되는 정보를 가지지 않는다. - 식별을 위함이므로 같은 값은 용납 ㄴㄴ해

 

 

 

- HINSTANCE  와 HWND 차이

 

- HWND =  핸들 윈도우 약자 , 윈도우의 핸들번호를 저장해서 사용 , 하나의 프로그램에서 많은양의 윈도우를 띄울수 있다.

               즉 윈도우창의 번호들(HWND) 로 구분하는것이다.

 

- HINSTANCE = 핸들 인스턴스  , 프로그램의 인스턴스 식별자 , 쉽게 보면 프로그램 자체의 실체화된 주소.

 

- 결론 : HINSTANCE는 프로그램 자체의 핸들이며 , HWND는 프로그램안의 윈도우창의 번호 !! 

 

- HDC

 

- Handle Device Context

- Device Context 란 ? 

- 출력에 필요한 정보를 가지는 데이터 구조체 , 좌표 ,색 ,굵기등 출력에 필요한 모든 정보를 담고있다

- 결국 HDC 란 DC의 정보를 저장하는 데이터 구조체의 위치를 알기위함.

- HDC는 포인터가 아니다 . 항상 실제 객체의 메모리 주소를 가르킬 뿐이다.

                                                                          -> 물리적으로 메모리 주소가 바뀌어도 , DC의 실제위치를 찾아감.




핸들이란 무엇인가?
커널 오브젝트를 사용하기 위해 필요한 하나의 장치
Os->프로세스를 사용하기 위해 핸들 테이블을 할당(GDI, User object는 헨들 테이블 할당 ㄴㄴ 고유의 핸들값만 받아서 사용)

핸들 테이블은 커널 오브젝트의 메모리 블록을 가리키는 포인터
액세스 마스크 접근권한 , 플래그 로 구성된 데이터 구조체 배열

그럼 왜 프로세스가 직접 커널 오브젝트를 사용안하고 os로 부터 핸들을 할당받나?
관리적 측면에서 프로세스가 접근해서 안될 영역을 판단하기위함(안전성)

커널 오브젝트 생성하는 함수를 호출 하고 사용후 반납.(안할시 메모리부족)
closeHandle(Handle obj); 해당 handle객체도 null init.


WinMain : https://softwareji.tistory.com/54

HINSTANCE VS HWND

HINSTANCE 핸들은 보통 실행되고 있는 WIN32 프로그램이 메모리상에 올라가 있는시작주소 값을 갖고 있다.
해당 주소에 실행 모듈에서 그 리소스를 읽으라고지정.(DLL)
프로그램의 핸들이 아닌 프로그램 코드를 담고있는 모듈의 핸들. -> 윈도우에서 관리하기 위한 일종의 고유 식별 번호 부여
기본적으로 프로세스를 실행하는 실행파일의 코드를 메모리에 올려놓은 모듈이 있어야하고 실행 파일의 모둘에 대한 인스턴스 핸들을
OS가 WINDMAIN의 인자로 넘겨주는 것 이다.
윈도우라는 OS에서 화면 출력을 위해 관리하는 리소스가 바로 HWND이다. MSN 메신저 등을 보면 알겠지만 하나의 프로그램이 하나의 창을 사용한다는 보장은 없다. 
오히려 99.99%의 프로그램은 한 개 이상의 윈도우로 구성되어 있다.
 한 프로그램의 윈도우가 겉보기에는 단일한 대상 영역으로 보일지라도 실제로는 구성요소별로 분리하여 별개의 윈도우로 만들어 
각 윈도우는 자기 자신이 맡은 부분에 대한 화면 출력과 사용자 입력만을 담당한다. 
자연히 하나의 프로그램에서 사용하는 HWND 타입의 개체 역시 1개 이상이 될 수 밖에 없으며, 
이러한 상황에서 특정 위치에 특정한 동작을 수행하기 위해서는 HWND로 대상 영역을 구분할 수 밖에 없다.


------------------------------------------------------------------------------------

HWND와 HINSTANCE의 구조체 내용을 보시면 가지는 속성들이 전혀 다릅니다.

HWND는 윈도우 자체에 대한 정보를 가지는 것이고,
HINSTANCE는 현재 실행중인 인스턴스에 관한 정보를 가지고 있습니다.
인스턴스는 운영체제 전체에서 유일한 번호를 가지므로(실행중인 창들이라고 보면되죠)
HWND를 가지고 인스턴스를 구할순 없지만 HINSTANCE를 가지고 있으면
HWND에 관한 내용들을 구할수 있습니다.